/*
주요 개념 요약:
오일러 경로(Eulerian path): 그래프에서 모든 간선을 정확히 한 번씩 지나가는 경로.

이 코드는 DFS(깊이 우선 탐색)를 활용한 백트래킹 방식으로 모든 가능한 오일러 경로를 출력합니다.

간선을 한 번 방문할 때마다 false로 바꾸고, 되돌아올 때 true로 복원합니다 (백트래킹).

필요하다면 이 그래프를 시각화하거나 출력되는 경로 개수를 세는 기능도 추가할 수 있어요.ㅋ
*/


#include <iostream>
using namespace std;

// 무방향 그래프의 인접 행렬 (1-based index)
// a[i][j]가 true이면 i와 j 사이에 간선이 있다는 뜻
bool a[6][6] = {
    {0},
    {0, 0, 1, 1, 0, 1}, // 정점 1과 연결된 정점: 2,3,5
    {0, 1, 0, 1, 0, 1}, // 정점 2와 연결된 정점: 1,3,5
    {0, 1, 1, 0, 1, 1}, // 정점 3과 연결된 정점: 1,2,4,5
    {0, 0, 0, 1, 0, 1}, // 정점 4와 연결된 정점: 3,5
    {0, 1, 1, 1, 1, 0}  // 정점 5와 연결된 정점: 1,2,3,4
};

// 경로를 저장할 배열 (최대 9개의 정점 방문 가능) 경로를 구성하는 정점의 개수는 간선 수 + 1
int path[10] = {0};

// 전체 간선 수 (무방향 그래프이므로 총 8개의 간선)
int cnt = 8;

// 현재 경로상의 위치 인덱스
int pos = 0;

// 오일러 경로를 탐색하는 재귀 함수
void Euler(int x) {
  int i;

  // 현재 정점을 경로에 저장
  path[pos++] = x;

  // 모든 간선을 다 사용한 경우 (정점 9개 방문 완료)
  if (pos == 9) {
    for (i = 0; i < pos; i++)
      cout << path[i]; // 경로 출력

    cout << endl;

    // 재귀 탈출을 위한 백트래킹
    pos--;
    return;
  }

  // 다음 방문할 인접 정점을 탐색
  for (i = 1; i <= 5; i++) {
    if (a[x][i]) { // 간선이 존재하는 경우
      // 간선을 사용했다고 표시 (양방향 모두 false로)
      a[x][i] = a[i][x] = false;

      // 재귀 호출로 다음 정점 방문
      Euler(i);

      // 백트래킹: 간선을 다시 원상 복구
      a[x][i] = a[i][x] = true;
    }
  }

  // 현재 위치에서 되돌아감
  pos--;
}

int main() {
  // 정점 1에서 오일러 경로 탐색 시작
  Euler(1);
  return 0;
}
